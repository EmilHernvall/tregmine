package info.tregmine;

import java.util.Set;
import java.util.HashSet;
import java.io.PrintStream;
import java.lang.reflect.*;
import java.util.Date;

public class DelegateGen
{
    public static void main(String[] args)
    {
        if (args.length != 2) {
            System.out.println("usage: java -jar delegate_gen.jar <src_name> <dst_name>");
            return;
        }

        generateDelegate(System.out, args[0], args[1]);
    }

    private static String serializeType(Type type)
    {
        StringBuilder buffer = new StringBuilder();
        if (type instanceof ParameterizedType) {
            ParameterizedType paramType = (ParameterizedType)type;
            buffer.append(serializeType(paramType.getRawType()));
            buffer.append("<");
            String delim = "";
            for (Type param : paramType.getActualTypeArguments()) {
                buffer.append(delim);
                buffer.append(serializeType(param));
                delim = ", ";
            }
            buffer.append(">");
        }
        else if (type instanceof Class) {
            Class classObj = (Class)type;
            String className = null;
            if (classObj.isArray()) {
                Class component = classObj.getComponentType();
                className = component.getName() + "[]";
            } else {
                className = classObj.getName();
            }
            className = className.replaceAll("\\$", ".");
            buffer.append(className);
        }
        else {
            buffer.append(type.toString());
        }

        return buffer.toString();
    }

    public static void generateDelegate(PrintStream out, String srcClass, String dstClass)
    {
        try {
            Class inspectClass = Class.forName(srcClass);

            String srcName = inspectClass.getName();
            //String[] srcNameSplit = srcName.split("\\.");
            //srcName = srcNameSplit[srcNameSplit.length-1];

            String dstName = dstClass;
            String[] dstNameSplit = dstName.split("\\.");
            dstName = dstNameSplit[dstNameSplit.length-1];
            String dstPackage =
                dstClass.substring(0, dstClass.length() - dstName.length() - 1);

            out.println("// Generated by delegate_gen on "  + new Date().toString());
            out.printf("package %s;\n", dstPackage);
            out.println();
            //out.printf("public abstract class %s implements %s\n", dstName, srcName);
            out.printf("public abstract class %s\n", dstName, srcName);
            out.println("{");
            out.printf("    private %s delegate;\n", srcName);
            out.println();
            out.printf("    protected %s(%s d)\n", dstName, srcName);
            out.println("    {");
            out.println("        this.delegate = d;");
            out.println("    }");
            out.println();
            out.printf("    public void setDelegate(%s v)\n", srcName);
            out.println("    {");
            out.println("        this.delegate = v;");
            out.println("    }");
            out.println();
            out.printf("    public %s getDelegate()\n", srcName);
            out.println("    {");
            out.println("        return delegate;");
            out.println("    }");
            out.println();
            out.println("    private void checkState()");
            out.println("    {");
            out.println("        if (delegate == null) {");
            out.println("            throw new IllegalStateException(");
            out.println("                \"Can't be used when delegate isn't set.\");");
            out.println("        }");
            out.println("    }");
            out.println();

            Set<String> seenWithoutParams = new HashSet<String>();

            Method[] methods = inspectClass.getMethods();
            for (Method method : methods) {
                Type[] params = method.getGenericParameterTypes();

                if (seenWithoutParams.contains(method.getName()) &&
                    params.length == 0) {

                    continue;
                }

                //out.println("    @Override");
                Deprecated depr = method.getAnnotation(Deprecated.class);
                if (depr != null) {
                    continue;
                    //out.println("    @SuppressWarnings(\"deprecated\")");
                }

                // Modifiers
                out.print("    public ");

                // Type Parameters
                TypeVariable[] typeVars = method.getTypeParameters();
                if (typeVars.length != 0) {
                    String delim = "";
                    out.print("<");
                    for (TypeVariable var : typeVars) {
                        out.print(delim);
                        out.print(var.getName());
                        Type[] bounds = var.getBounds();
                        if (bounds.length != 0) {
                            out.print(" extends ");
                            String delim2 = "";
                            for (Type bound : bounds) {
                                out.print(delim);
                                out.print(serializeType(bound));
                                delim2 = ", ";
                            }
                        }
                        delim = ", ";
                    }
                    out.print("> ");
                }

                // Return Type
                Class returnType = method.getReturnType();
                Type genReturnType = method.getGenericReturnType();
                if (genReturnType != null) {
                    out.print(serializeType(genReturnType));
                } else {
                    out.print(returnType.getName());
                }
                out.print(" ");

                // Method Name
                out.print(method.getName());

                out.print("(");
                String delim = "";
                int i = 0;
                for (Type param : params) {
                    out.print(delim);
                    out.print(serializeType(param));
                    out.print(" ");
                    out.print("p" + i);
                    delim = ", ";
                    i++;
                }
                out.println(")");

                // Body
                out.println("    {");
                out.println("        checkState();");

                if (returnType != Void.TYPE) {
                    out.print("        return ");
                } else {
                    out.print("        ");
                }
                out.print("delegate.");
                out.print(method.getName());
                out.print("(");
                delim = "";
                i = 0;
                for (Type param : params) {
                    out.print(delim);
                    out.print("p" + i);
                    delim = ", ";
                    i++;
                }
                out.print(");");
                out.println();

                out.println("    }");
                out.println();

                if (params.length == 0) {
                    //System.out.println("seenWithoutParams: " + method.getName());
                    seenWithoutParams.add(method.getName());
                }
            }

            out.println("}");
        }
        catch (ClassNotFoundException e) {
            System.err.println(srcClass + " was not found!");
        }
    }
}
